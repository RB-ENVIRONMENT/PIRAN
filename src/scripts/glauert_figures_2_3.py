# This script allows you to generate figures similar to Figures 2 and 3
# from Glauert & Horne (2005).
#
# To use it:
#
# 1. Data directories: You need data from at most two separate simulations
#    with different plasma over gyrofrequency ratios (denoted by `r1` and
#    `r2`). These directories should contain output files named
#    `results*.json` generated by either the `diffusion_coefficients.py` or
#    `bounce_averaged_diffusion_coefficients.py` script. Use the `--r1` (or
#    `-r1`) and `--r2` (or `-r2`) options to specify the paths to these
#    directories.
# 2. Figure selection: Choose which figure you want to create by using the
#    `--fig` (or `-f`) option. Enter either `2` for a figure resembling
#    Figure 2 or `3` for a figure resembling Figure 3 from the original paper.
# 3. Saving the figure (optional): If you want to save the generated figure as
#    an image file, use the `-s` argument. This will save the image as
#    "PIRAN_Glauert_Figure{figure_number}.png" in the directory where you run
#    the script.
#
# Example usage:
#
# python src/scripts/glauert_figures_2_3.py \
#     --r1 "PATH/TO/cunningham_1.5" \
#     --r2 "PATH/TO/cunningham_10.0" \
#     --fig 2
import argparse
import json
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from astropy import units as u
from matplotlib.ticker import LogFormatterMathtext

from piran.diffusion import UNIT_DIFF, get_energy_diffusion_coefficient, get_mixed_aE_diffusion_coefficient


def load_and_post_process(pathname, bounce=False):
    """
    `pathname` must contain the `results*.json` files produced by the
    `diffusion_coefficients.py` (`bounce=False`) or the
    `bounce_averaged_diffusion_coefficients.py` (`bounce=True`) script.
    """

    pitch_angles = []
    Daa_over_p_squared = []
    DaE_over_E_squared_abs = []
    DEE_over_E_squared = []

    files = list(Path(pathname).glob("results*.json"))
    if len(files) == 0:
        raise FileNotFoundError(f"'results*.json' files not found in {pathname}")

    for file in files:
        with open(file, "r") as f:
            results = json.load(f)

        if bounce:
            alpha = results["equatorial_pitch_angle"]
        else:
            alpha = results["pitch_angle"]

        momentum = results["momentum"]
        rest_mass_energy_J = results["rest_mass_energy_Joule"] << u.J
        rel_kin_energy_MeV = results["rel_kin_energy_MeV"] << u.MeV
        rel_kin_energy_J = (rel_kin_energy_MeV).to(u.J)

        method = results["method"]
        ratio = results["plasma_over_gyro_ratio"]

        if bounce:
            Daa = results["baDaa"] << UNIT_DIFF
            Dap = results["baDap"] << UNIT_DIFF
            Dpp = results["baDpp"] << UNIT_DIFF
        else:
            Daa = results["Daa"] << UNIT_DIFF
            Dap = results["Dap"] << UNIT_DIFF
            Dpp = results["Dpp"] << UNIT_DIFF

        DaE = get_mixed_aE_diffusion_coefficient(rel_kin_energy_J, rest_mass_energy_J, Dap)
        DEE = get_energy_diffusion_coefficient(
            rel_kin_energy_J, rest_mass_energy_J, Dpp
        )

        pitch_angles.append(alpha)
        Daa_over_p_squared.append(Daa.value / momentum**2)
        DaE_over_E_squared_abs.append(abs(DaE.value) / rel_kin_energy_J.value**2)
        DEE_over_E_squared.append(DEE.value / rel_kin_energy_J.value**2)

    # Sort by pitch angle
    sorted_vals = sorted(zip(pitch_angles, Daa_over_p_squared), key=lambda z: z[0])
    yy_aa = [z[1] for z in sorted_vals]

    sorted_vals = sorted(zip(pitch_angles, DaE_over_E_squared_abs), key=lambda z: z[0])
    yy_aE = [z[1] for z in sorted_vals]

    sorted_vals = sorted(zip(pitch_angles, DEE_over_E_squared), key=lambda z: z[0])
    yy_EE = [z[1] for z in sorted_vals]

    xx = [z[0] for z in sorted_vals]

    return xx, yy_aa, yy_aE, yy_EE, method, ratio, rel_kin_energy_MeV


def plot_figure(
    ax,
    xx,
    yy,
    color,
    linestyle,
    marker,
    alpha,
    label,
):
    ax.semilogy(
        xx,
        yy,
        color=color,
        linestyle=linestyle,
        marker=marker,
        alpha=alpha,
        label=label,
    )


def format_figure(fig, axs, fid, energy):
    xticks = list(range(0, 91, 20))
    yticks = [10 ** (n) for n in range(-7, -1, 1)]

    x_lim_min = xticks[0]
    x_lim_max = 90  # xticks[-1]

    y_lim_min = yticks[0]
    y_lim_max = yticks[-1]

    if fid == 2:
        langle = ""
        rangle = ""
        fig.supxlabel(r"Pitch Angle $\alpha^{\circ}$")
    elif fid == 3:
        langle = r"\langle"
        rangle = r"\rangle"
        fig.supxlabel(r"Pitch Angle $\alpha_{\text{eq}}^{\circ}$")
    else:
        raise ValueError("Wrong figure id")

    for ii, ax in enumerate(axs):
        ax.set_xticks(xticks, labels=[str(v) for v in xticks])
        ax.set_yticks(yticks, labels=[str(v) for v in yticks])

        ax.yaxis.set_major_formatter(LogFormatterMathtext())

        ax.tick_params("x", which="both", top=True, labeltop=False)
        ax.tick_params("y", which="both", right=True, labelright=False)

        ax.set_xlim(x_lim_min, x_lim_max)
        ax.set_ylim(y_lim_min, y_lim_max)

        if ii == 0:
            ax.set_ylabel(rf"${langle}\text{{D}}_{{\alpha\alpha}}{rangle} / \text{{p}}^2$")
        elif ii == 1:
            ax.set_ylabel(rf"$|{langle}\text{{D}}_{{\alpha\text{{E}}}}{rangle}| / \text{{E}}^2$")
        elif ii == 2:
            ax.set_ylabel(rf"${langle}\text{{D}}_{{\text{{EE}}}}{rangle} / \text{{E}}^2$")

        ax.legend(loc="lower left")

    fig.suptitle(f"KE={energy.to(u.keV):.0f}")
    fig.tight_layout()


def main():
    plt.rcParams.update(
        {
            "text.usetex": False,
            "font.size": 12,
        }
    )

    parser = argparse.ArgumentParser(
        prog="Glauert_Horne_2005_Figures_2_&_3",
        description="Reproduce Figures 2 or 3 from Glauert & Horne, 2005",
    )
    parser.add_argument(
        "-f",
        "--fig",
        required=True,
        type=int,
        choices=[2, 3],
        help="Figure identifier.",
    )
    parser.add_argument(
        "--r1",
        default=None,
        help="Path to directory with results*.json files for 1st ratio.",
    )
    parser.add_argument(
        "--r2",
        default=None,
        help="Path to directory with results*.json files for 2nd ratio.",
    )
    parser.add_argument(
        "-s",
        "--save",
        action="store_true",
        default=False,
        help="Pass this argument to save the figure on disk.",
    )
    args = parser.parse_args()

    if args.fig == 2:
        bounce = False
    elif args.fig == 3:
        bounce = True
    else:
        raise ValueError("Wrong figure id")

    # Init figure and axes
    fig, axs = plt.subplots(
        nrows=3,
        ncols=1,
        sharex=False,
        figsize=(6, 15),
    )

    # Plot data
    if args.r1 is not None:
        xx, yy_aa, yy_aE, yy_EE, method, ratio, energy = load_and_post_process(args.r1, bounce)

        if method == 0:
            method_label = "Glauert"
        elif method == 1:
            method_label = "Cunningham"
        else:
            raise ValueError("Unknown normalisation method")

        label = rf"{method_label} $\omega_{{\text{{pe}}}}/\omega_{{\text{{ce}}}}={ratio}$"
        plot_figure(axs[0], xx, yy_aa, "C0", "-", "", 1.0, label)
        plot_figure(axs[1], xx, yy_aE, "C0", "-", "", 1.0, label)
        plot_figure(axs[2], xx, yy_EE, "C0", "-", "", 1.0, label)

    if args.r2 is not None:
        xx, yy_aa, yy_aE, yy_EE, method, ratio, energy = load_and_post_process(args.r2, bounce)

        if method == 0:
            method_label = "Glauert"
        elif method == 1:
            method_label = "Cunningham"
        else:
            raise ValueError("Unknown normalisation method")

        label = rf"{method_label} $\omega_{{\text{{pe}}}}/\omega_{{\text{{ce}}}}={ratio}$"
        plot_figure(axs[0], xx, yy_aa, "C1", "-", "", 1.0, label)
        plot_figure(axs[1], xx, yy_aE, "C1", "-", "", 1.0, label)
        plot_figure(axs[2], xx, yy_EE, "C1", "-", "", 1.0, label)

    # Format the figure, add legend, labels etc.
    format_figure(fig, axs, args.fig, energy)

    if args.save:
        plt.savefig(f"PIRAN_Glauert_Figure{args.fig}.png", dpi=150)
    else:
        plt.show()


if __name__ == "__main__":
    main()
